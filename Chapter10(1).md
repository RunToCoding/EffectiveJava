# 10장. 예외

<br>

## *아이템 69.* 예외는 진짜 예외 상황에서만 사용하라 *(p.386)*

- 예외를 일상적인 **제어 흐름용으로 쓰면 안 됨**!
    - e.g. **반복문 종료**를 위해 예외 `ArrayIndexOutOfBoundsException` 사용
    - 장황하며 속도도 느리고, 엉뚱한 곳에서 발생한 **버그를 숨김**
    
- 잘 설계된 API라면 클라이언트가 제어 흐름에서 **예외를 사용할 일이 없게** 해야 함.
    - 특정 상태에서만 호출할 수 있는 **‘상태 의존적’ 메서드를 제공하는 클래스**는 **‘상태 검사’ 메서드도 함께 제공**해야 함
    - e.g. `Iterator` 인터페이스의 `next`는 상태 의존적 메서드, `hasNext`는 상태 검사 메서드
        - 별도의 상태 검사 메서드 덕분에 표준 `for` **관용구 사용이 가능**해짐!
        
        ```java
        for (Iterator<Foo> i = collection.iterator(); i.hasnext(); ) {
        	Foo foo = i.next();
        	...
        }
        ```
        
- 상태 의존적 메서드를 위해 사용 가능한 선택지
    1. 상태 검사 메서드
    2. 빈 옵셔널 반환
    3. 특정 값(e.g. `null`) 반환
    
    - **옵셔널 or 특정 값**을 사용하는 것이 좋은 경우?
        - 외부 동기화 없이 **여러 스레드가 동시에 접근**할 수 있거나 **외부 요인으로 상태가 변할 수 있는 경우**
        - **성능이 중요**한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 **작업 일부를 중복 수행**하는 경우
    - 이를 제외한 모든 경우에는 상태 검사 메서드 방식이 더 나음

<br><br>

## *아이템 70.* 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라 *(p.390)*

> JAVA의 문제 상황을 알리는 타입(throwable) 3가지 - 검사 예외, 런타임 예외, 에러
> 

⇒ 언제 무엇을 사용해야하는지?

- 호출하는 쪽에서 **복구하리라 여겨지는 상황**이라면 **검사 예외** 사용
    - 검사 예외를 던지면 **호출자**가 그 **예외를** `catch`**로 잡아 처리**하거나 더 **바깥으로 전파**하도록 강제하게 됨
    - 메서드 선언에 포함된 검사 예외는 그 메서드를 호출했을 때 **발생할 수 있는 유력한 결과임을 API 사용자에게 알려주는 것** (사용자에게 회복해내라고 요구)
    - 호출자가 **예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공**해야 함

**비검사 throwable - 런타임 예외, 에러** : 프로그램에서 잡을 필요가 없거나 잡지 말아야 함 (복구가 불가능하거나 더 실행해봐야 득보다 실이 많다는 뜻)

- **프로그래밍 오류**를 나타낼 때는 **런타임 예외** 사용
    - 런타임 예외는 대부분 **전제조건을 만족하지 못했을 때**(클라이언트가 API 명세에 기록된 제약을 지키지 못했을 때) 발생
        - e.g. 배열의 인덱스는 `0`에서 `배열 크기 -1` 사이여야 하는데, `ArrayIndexOutOfBoundsException`은 이 전제조건이 지켜지지 않았다는 뜻
    - 조건에 대해 생긴 문제가 **복구가 가능하지 않다고 판단**되거나 **확신하기 어렵다면** 런타임 예외 사용

- JVM이 **자원 부족**, **불변식 깨짐** 등 더 이상 **수행을 계속할 수 없는 상황**을 나타낼 때 **에러** 사용
    - `Error` 클래스를 상속해 하위 클래스를 만들거나 `throw`문으로 던지지 말 것
    - 우리가 구현하는 비검사 throwable은 모두 `RuntimeException`의 하위 클래스여야 함.

- `Exception`, `RuntimeException`, `Error`를 상속하지 않는 (검사 예외도 아니고 런타임 예외도 아닌) throwable은 사용하지 말 것

<br><br>

## *아이템 71.* 필요 없는 검사 예외 사용은 피하라 *(p.393)*

- **검사 예외를 과하게 사용**하면 **쓰기 불편한 API**가 됨 (`try/catch` 블록을 추가해야하고, 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없음 *(아이템 45-48)*
- API를 **제대로 사용해도 발생할 수 있는 예외**이거나, 프로그래머가 **의미 있는 조치를 취할 수 있는 경우**가 아니라면 **비검사 예외를 사용**하는 것이 좋음

- **검사 예외를 회피**하는 방법
    1. **빈 옵셔널 반환***(아이템 55)* - 예외가 발생한 이유를 알려주는 **부가 정보를 담을 수 없다**는 단점
    2. 검사 예외를 던지는 **메서드를 2개로 쪼개 비검사 예외로 바꿈**
        
        ```java
        /* 검사 예외를 던지는 메서드 - 리팩터링 전 */
        try {
        	obj.action(args);
        } catch (TheCheckedException e) {
        	...
        }
        ```
        
        ```java
        /* 상태 검사 메서드와 비검사 예외를 던지는 메서드 - 리팩터링 후 */
        if (obj.actionPermitted(args)) {
        	obj.action(args);
        } else {
        	...
        }
        ```
        

### 정리

- 호출자가 예외 상황에서 복구할 방법이 없다면 - **비검사 예외**
- 복구 가능하고 호출자가 예외를 처리하기를 바란다면 - 1. **옵셔널 반환** 2. 옵셔널만으로는 충분한 정보를 제공할 수 없을 때만 **검사 예외**

<br><br>

## *아이템 72.* 표준 예외를 사용하라 *(p.396)*

일반 코드와 마찬가지로 예외도 **재사용**하는 것이 좋음

### 널리 재사용되는 예외

- `IllegalArgumentException` *(아이템 49)*: **인수로 부적절한 값**을 넘길 때
    - 특수한 경우로 `NullPointerException`, `IndexOutOfBoundsException`
- `IllegalStateException` : 객체가 메서드를 수행하기에 **적절하지 않은 상태**일 때
    - e.g. 제대로 초기화되지 않은 경우
- `ConcurrentModificationException` : **단일 스레드에서 사용**하거나 **외부 동기화 방식**으로 사용하려고 설계한 객체를 **여러 스레드가 동시에 수정**하려 할 때
- `UnsupportedOperationException` : 호출한 **메서드를 지원하지 않을 때**
    - e.g. `List` 구현체에 `remove` 메서드를 호출하는 경우
    

`IllegalArgumentException` vs `IllegalStateException`

- 예외의 원인을 무엇으로 보는지에 따라 다르게 선택할 수 있음
- **인수 값이 무엇이었든 실패**했을 거라면 `IllegalArgumentException`, 그렇지 않으면 `IllegalStateException`을 던지면 됨
